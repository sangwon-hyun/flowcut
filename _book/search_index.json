[["index.html", "Creating the flowcut R package 1 Introduction", " Creating the flowcut R package Sheng Jiang, Sangwon Hyun 2024-10-27 1 Introduction This package implements flowcut, a Bayesian mixture of experts model used for censored data (specialized for ocean flow cytometry). The documentation and package are both created using one simple command: litr::render(&quot;index.Rmd&quot;, output_format = litr::litr_gitbook()) ## install.packages(&quot;./flowcut/&quot;, repos = NULL, type=&quot;source&quot;) This line is purely for testing (to be deleted later!). litr::load_all(&quot;index.Rmd&quot;)##, output_format = litr::litr_gitbook()) my_load &lt;- function(){ litr::render(&quot;~/repos/flowcut/index.Rmd&quot;, output_format = litr::litr_gitbook(minimal_eval = TRUE)) devtools::load_all(&quot;~/repos/flowcut/flowcut&quot;) } my_load() devtools::check(&quot;~/repos/flowcut/flowcut&quot;, document = FALSE) "],["package-setup.html", "2 Package setup", " 2 Package setup The DESCRIPTION file is created using this code. usethis::create_package( path = &quot;.&quot;, fields = list( Package = params$package_name, Version = &quot;0.0.0.9000&quot;, Title = &quot;flowcut&quot;, Description = &quot;Time-smooth mixture modeling for flow cytometry data.&quot;, `Authors@R` = person( given = &quot;Sangwon&quot;, family = &quot;Hyun&quot;, email = &quot;sangwonh@ucsc.edu&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;) ) ) ) usethis::use_mit_license(copyright_holder = &quot;Sangwon Hyun&quot;) The following is what will show up when someone types package?flowcut in the console. #&#39; flowcut #&#39; #&#39; This package implements the `flowcut` method. #&#39; #&#39; @docType package This package will have some dependancies: library(tidyverse) ##library(ggplot2) ##usethis::use_package(&quot;tidyverse&quot;, type = &quot;depends&quot;) ## usethis::use_package(&quot;ggplot2&quot;) usethis::use_package(&quot;ggplot2&quot;, type = &quot;depends&quot;) usethis::use_package(&quot;MASS&quot;, type = &quot;depends&quot;) usethis::use_package(&quot;parallel&quot;, type = &quot;depends&quot;) usethis::use_package(&quot;Rfast&quot;, type = &quot;depends&quot;) usethis::use_package(&quot;mvnfast&quot;, type = &quot;depends&quot;) usethis::use_package(&quot;stats&quot;, type = &quot;depends&quot;) usethis::use_package(&quot;matrixsampling&quot;, type = &quot;depends&quot;) usethis::use_package(&quot;matrixNormal&quot;, type = &quot;depends&quot;) usethis::use_package(&quot;pgdraw&quot;, type = &quot;depends&quot;) usethis::use_package(&quot;tmvnsim&quot;, type = &quot;depends&quot;) usethis::use_pipe(export=TRUE) "],["helpers-functions.html", "3 Helpers functions", " 3 Helpers functions These are some helper functions that are needed for the MCMC. These functions are not documented for now. (TODO: do this). #&#39; A helper function to print the progress of a simulation. Place directly at #&#39; the beginning of the loop, before any computation happens. #&#39; @param isim isim. #&#39; @param nsim number of sim. #&#39; @param type type of job you&#39;re running. Defaults to &quot;simulation&quot;. #&#39; @param lapsetime lapsed time, in seconds (by default). #&#39; @param lapsetimeunit &quot;second&quot;. #&#39; @param start.time Start time, usually obtained using \\code{Sys.time()} #&#39; @param fill Whether or not to fill the line. #&#39; @param beep Whether to beep when done. printprogress &lt;- function(isim, nsim, type=&quot;simulation&quot;, lapsetime=NULL, lapsetimeunit=&quot;seconds&quot;, start.time=NULL, fill=FALSE, beep=FALSE){ ## If lapse time is present, then use it if(fill) cat(fill=TRUE) if(is.null(lapsetime) &amp; is.null(start.time)){ cat(&quot;\\r&quot;, type, &quot; &quot;, isim, &quot;out of&quot;, nsim) } else { if(!is.null(start.time)){ if(isim == 1){ lapsetime = 0 remainingtime = &quot;unknown&quot; endtime = &quot;unknown time&quot; } else { lapsetime = round(difftime(Sys.time(), start.time, units = &quot;secs&quot;), 0) remainingtime = round(lapsetime * (nsim - (isim - 1)) / (isim - 1), 0) endtime = strftime((Sys.time() + remainingtime)) } } cat(&quot;\\r&quot;, type, &quot; &quot;, isim, &quot;out of&quot;, nsim, &quot;with lapsed time&quot;, lapsetime, lapsetimeunit, &quot;and remaining time&quot;, remainingtime, lapsetimeunit, &quot;and will finish at&quot;, endtime, &quot;.&quot;) if(beep &amp; isim==nsim){beepr::beep()} } if(fill) cat(fill=TRUE) } #&#39; Helper function to print progress. #&#39; #&#39; @param iter Current iteration. #&#39; @param Nmc Total number of MCMC iterations. #&#39; #&#39; @export progress &lt;- function(iter, Nmc){ cat(&quot;MCMC iteration: &quot;, iter, &quot;.&quot;, round(iter/Nmc,3)*100, &quot;% is done&quot;, fill = TRUE) } wcrossprod.fast &lt;- function(x, w.sqrt, weighting = TRUE){ if(weighting){ x &lt;- x * w.sqrt } return(Rfast::Crossprod(x,x)) } #&#39; self.crossprod &lt;- function(x){ ## this function can be deleted. if(ncol(x) == 1){ ret &lt;- x %*% t(x) }else{ ret &lt;- crossprod(x) } return(ret) } #&#39; logsumexp &lt;- function (x) { y = max(x) y + log(sum(exp(x - y))) } #&#39; softmax &lt;- function (x) { exp(x - logsumexp(x)) } #&#39; softmax2 &lt;- function(x){ return(exp(x)/sum(exp(x))) } #&#39; logMNdensity &lt;- function(y,invSig,logdet){ ## The term &quot;-log(2*pi)*d/2&quot; is omitted return(- Rfast::Crossprod(y, invSig) %*% y /2 - logdet/2) } #&#39; KL.MN &lt;- function(p,q){ sum(p*log(p/q)) } #&#39; pgdraw.mod &lt;- function(b,c){ if(b&gt;0){ ret &lt;- pgdraw::pgdraw(b,c) }else{ ## print(&quot;in pgdraw: b=0&quot;) ret &lt;- 0 } return(ret) } #&#39; Helper to change stick-breaking vector |pi.sb| to regular probabilities. #&#39; @param pi.sb Stickbreaking probability vector. #&#39; #&#39; @return same sized vector of size K. #&#39; #&#39; @export SB2MN &lt;- function(pi.sb){ pi.sb &lt;- c(pi.sb,1) ## append 1 K &lt;- length(pi.sb) pi.mn &lt;- rep(0,K) pi.mn[1] &lt;- pi.sb[1] for(kk in 2:K){ pi.mn[kk] &lt;- pi.sb[kk]*(1-sum(pi.mn)) } return(pi.mn) } #&#39; Helper to change stick-breaking vector |pi.sb| to regular probabilities. The #&#39; opposite function of SB2MN. #&#39; @param pi.mn Probability vector. #&#39; #&#39; @return same sized vector of size K. #&#39; #&#39; @export MN2SB &lt;- function(pi.mn){ K &lt;- length(pi.mn) pi.sb &lt;- rep(0,K-1) pi.cs &lt;- cumsum(pi.mn[-K]) pi.sb[1] &lt;- pi.mn[1] pi.sb[2:(K-1)] &lt;- pi.mn[2:(K-1)]/(1-pi.cs[-(K-1)]) return(pi.sb) } #&#39; gamma2pi &lt;- function(gamma,Xp){ XpGamma &lt;- Rfast::Crossprod(gamma, Xp) ## K-1 x T pi.sb &lt;- 1/(1+exp(-XpGamma)) return(pi.sb) } #&#39; dtaMatCensor &lt;- function(x,Cbox){ d &lt;- dim(x)[2] for(ii in 1:d){ x[,ii] &lt;- pmin(pmax(x[,ii],Cbox[ii,1]),Cbox[ii,2]) } return(x) } #&#39; censorIndicator &lt;- function(x,Cbox){ d &lt;- dim(Cbox)[1] if(dim(x)[2]!=d &amp; dim(x)[1]==d){ x &lt;- t(x) } for(ii in 1:d){ x[,ii] &lt;- (x[,ii]==Cbox[ii,2]) - (x[,ii]==Cbox[ii,1]) } return(x) } #&#39; sample.region &lt;- function(cc,Cbox){ limits &lt;- NULL d &lt;- length(cc) for(i in 1:d){ if(cc[i]==-1){ limits &lt;- rbind(limits, c(-Inf,Cbox[i,1])) }else if(cc[i]==0){ limits &lt;- rbind(limits, c(-Inf,Inf)) }else{ limits &lt;- rbind(limits, c(Cbox[i,2], Inf)) } } colnames(limits) &lt;- c(&quot;lower&quot;,&quot;upper&quot;) return(limits) } #&#39; rmatnorm.fast &lt;- function(M,U,V){ ## M is d x p ## U is d x d ## V is p x p M &lt;- as.matrix(M) U &lt;- as.matrix(U) V &lt;- as.matrix(V) d &lt;- nrow(M) ## dim of U p &lt;- ncol(M) ## dim of V chol.U &lt;- Rfast::cholesky(U) ## upper triangular matrix chol.V &lt;- Rfast::cholesky(V) x &lt;- Rfast::matrnorm(d, p) return(Rfast::Crossprod(chol.U, x) %*% chol.V + M) } #&#39; samp.trunc.normal &lt;- function(yy, zz, cc.info, bounds.info, mu.mat, Sigma.ell, dimdat){ cc &lt;- abs(cc.info)==1 nc &lt;- cc==0 d &lt;- length(cc.info) lower.info &lt;- bounds.info[1:d] upper.info &lt;- bounds.info[(d+1):(2*d)] mu &lt;- mu.mat[,zz] ## If all dimensions are censored. if(all(cc)){ sig = Sigma.ell[,,zz] if(dimdat==1) sig = as.matrix(sig) yy &lt;- tmvnsim::tmvnsim(nsamp=1,d,lower=lower.info,upper=upper.info, mean= mu, sigma = sig)$samp ## If /not/ all dimensions are censored. } else { ## Conditional mean and variance slope &lt;- Sigma.ell[cc,nc,zz] %*% solve(Sigma.ell[nc,nc,zz]) cond.sig &lt;- Sigma.ell[cc,cc,zz] - slope %*% Sigma.ell[nc,cc,zz] cond.m &lt;- mu[cc]+slope %*% (yy[nc]-mu[nc]) ## Sample from this conditional truncated normal if(dimdat==1) cond.sig = as.matrix(cond.sig) stopifnot(&quot;matrix&quot; %in% class(cond.sig)) imputed_y = tmvnsim::tmvnsim(nsamp = 1, length(cond.m), lower=lower.info[cc], upper = upper.info[cc], mean= cond.m, sigma = cond.sig)$samp yy[cc] &lt;- imputed_y } if(!is.numeric(yy)) browser() return(yy) } #&#39; impute.censored &lt;- function(ww, yy, zz, cc.info.mat, bounds.mat, mu.mat, Sigma.ell, dimdat){ ## Setup stopifnot(&quot;array&quot; %in% class(Sigma.ell)) if(length(zz) == 0){ ret &lt;- NULL }else if (length(zz)==1){ ret &lt;- samp.trunc.normal(yy, zz, cc.info.mat, bounds.mat, mu.mat, Sigma.ell, dimdat) } else { ret &lt;- t(sapply(1:length(zz), function(ii) samp.trunc.normal(yy[ii,], zz[ii], cc.info.mat[ii,], bounds.mat[,ii], mu.mat, Sigma.ell, dimdat))) } return(ret) } #&#39; gen.syn.dta &lt;- function(T, K, p, d=3, Cbox=NULL, Pi =NULL, avg.clust.size=100){ ## this function can be deleted ### by default, d = 3 nt &lt;- stats::rpois(n=T,lambda=avg.clust.size*K) X &lt;- t(sapply(1:p, function(pp) stats::arima.sim(list(order=c(1,0,0), ar=pp/(pp+1)/2), n=T))) Beta &lt;- array(stats::rnorm(K*p*d), c(d,p,K)) beta0 &lt;- matrix(stats::rnorm(K*d), nrow=d,ncol=K) if(is.null(Pi)){ Gamma0 &lt;- matrix(stats::rnorm(K*p), nrow= p, ncol = K) Gamma0 &lt;- t(apply(Gamma0,1,function(x) x-x[K]))/10 gamma0 &lt;- (1:K)/1 Pi &lt;- t(apply(t(X) %*% Gamma0+gamma0, 1, function(x) exp(x)/sum(exp(x)))) } Sigma &lt;- stats::rWishart(K, 1, diag(d)) Z.list &lt;- lapply(1:T, function(tt) sample(1:K, nt[[tt]], prob = Pi[tt,],replace = TRUE)) Y.list &lt;- NULL for(t in 1:T){ Z &lt;- Z.list[[t]] Y.list[[t]] &lt;- t(sapply(Z,function(z) MASS::mvrnorm(n=1, mu = beta0[,z]+Beta[,,z]%*%X[,t],Sigma = Sigma[,,z]))) } Ytrue.list &lt;- Y.list if(is.null(Cbox)==FALSE){ Y.list &lt;- lapply(Y.list, function(x) dtaMatCensor(x,Cbox)) } return(list(Y.list=Y.list, X=X, Z.list=Z.list, nt=nt, Cbox=Cbox, K=K, Ytrue.list = Ytrue.list, Pi = Pi, beta0 = beta0, Beta = Beta, Sigma = Sigma)) } #&#39; loglik_eval &lt;- function(mu.list, chol.Sig.list, W.list, X.list, Y.list, Z.list, nt.list, simple = FALSE, n.cores = 1){ ## logPiZ &lt;- mcmapply(function(xx,yy,mm){sapply(1:K, function(kk) ## mvnfast::dmvn(yy, mm[,kk], chol.Sig.list[[kk]],log=TRUE,isChol = TRUE)) }, ## xx=X.list, yy = Y.list, mm=mu.list, mc.cores = min(n.cores, T), ## SIMPLIFY = FALSE) if(simple == TRUE){ ll.vec &lt;- sapply(1:nt.list[[1]], function(id) mvnfast::dmvn(Y.list[[1]][id,], mu.list[[1]][,Z.list[[1]][id]], chol.Sig.list[[Z.list[[1]][id]]], log=TRUE, isChol = TRUE)) out &lt;- sum(ll.vec * W.list[[1]]) / nt.list[[1]] }else{ ll.sums &lt;- parallel::mcmapply(function(ww, xx,yy,mm,zz,nt){ sum(ww * sapply(1:nt,function(id) mvnfast::dmvn(yy[id,], mm[,zz[id]], chol.Sig.list[[zz[id]]], log=TRUE,isChol = TRUE)) )}, ww = W.list, xx = X.list, yy = Y.list, mm=mu.list, zz = Z.list, nt = nt.list, mc.cores = min(n.cores, T), SIMPLIFY = TRUE) out &lt;- Reduce(&quot;+&quot;,ll.sums)/sum(unlist(nt.list)) } return(out) } Here’s a function that makes a censoring box (dimdat by 2 matrix, where the first column is the lower cutoff, and the second column is the upper cutoff). #&#39; #&#39; @param ylist Data with censored particles inside. #&#39; #&#39; @export get_Cbox &lt;- function(ylist){ ## Setup dimdat = ncol(ylist[[1]]) ## Define censor limits bounds.lower &lt;- Rfast::rowMins(matrix(unlist( lapply(ylist, function(xx) Rfast::colMins(xx,value = TRUE))), nrow = dimdat), value = TRUE) bounds.upper &lt;- Rfast::rowMaxs(matrix(unlist( lapply(ylist, function(xx) Rfast::colMaxs(xx,value = TRUE))), nrow = dimdat), value = TRUE) ## Modify censorship slightly Cbox &lt;- cbind(bounds.lower, bounds.upper) } #&#39; Obtain the g parameter by simulation. #&#39; #&#39; @param X the design matrix, TT by p, (that doesn&#39;t include the intercept) #&#39; @param dimdat the dimension of the cytogram space #&#39; @param maxdev Maximum deviation of cluster means away from its grand mean. #&#39; @param numclust the number of experts #&#39; @param ggvec the vector of g parameter values to calculate the prior probability by Monte Carlo samples #&#39; @param Nmc Monte Carlo simulation sample size, with default value being 1e4. #&#39; @param n.cores the number of CPU cores to be used for parallelization #&#39; @param viz show the plot of the fitted relationship between the g parameter and the prior probability. #&#39; #&#39; #&#39; @return the g parameter with desired prior probability on maxdev #&#39; #&#39; @export maxdev_to_gg &lt;- function(X, dimdat, maxdev, numclust, ggvec, Nmc = 1e4 , prior.prob = 0.99, viz = FALSE, n.cores = 1, verbose = FALSE){ ## X is T x p ## Basic setup p = ncol(X) ## 39 d = dimdat #&#39; Helper function #&#39; @param tX is the transpose of X ball.deviance &lt;- function(gg, rr, tX, Nmc=5000, nu0=d, nu1=p+1, S0=diag(d), S1=diag(p+1)){ inv.XTX &lt;- solve(tcrossprod(tX)) max.deviance &lt;- rep(NA,Nmc) Sig.ell &lt;- matrixsampling::rinvwishart(Nmc,nu0+d,S0) beta.ell &lt;- apply(Sig.ell,3,function(xx) as.matrix(matrixNormal::rmatnorm(M = matrix(0,d,p), U = xx, V = inv.XTX*gg, tol = .Machine$double.eps^0.5)), simplify = FALSE) xb &lt;- lapply(beta.ell, function(bb) bb%*% tX) # length of list: Nmc # each element: d x T max.deviance &lt;- lapply(xb, function(mat){ apply(mat,2,function(cols) crossprod(cols)) %&gt;% max() }) %&gt;% unlist() prob &lt;- mean(max.deviance &lt;= rr^2) return(list(gg = gg, rr = rr, prob = prob)) } gglist &lt;- as.list(ggvec)##as.list(1:40/100) n.cores &lt;- min(n.cores, length(gglist)) plist &lt;- parallel::mclapply(1:length(gglist), function(igg){ if(verbose) printprogress(igg) gg = gglist[[igg]] ball.deviance(gg, maxdev, t(X), Nmc = Nmc)$prob }, mc.cores = n.cores) ## Make linear interpolation at a fine grid res = stats::approx(x = unlist(gglist), y = unlist(plist), method=&quot;linear&quot;, n = 100) newx = res$x newy = res$y ## Get closest point imin = which.min(abs(newy - prior.prob ^(1/numclust))) ## Make some plots to confirm if(viz){ plot(gglist,plist,type = &quot;l&quot;, ylab = &quot;Prob outside of \\n radius r&quot;, xlab = &quot;Value of |gg|&quot;) graphics::abline(h=0.05,lwd=2,col = &quot;red&quot;) graphics::abline(h=0.01,lwd=2,col = &quot;red&quot;) ## lines(y=newy, x=newx,lwd=2,col=&quot;blue&quot;) ## abline(v=newx[imin]) } return(newx[imin]) } Here’s a function to take the stick-breaking \\(\\gamma\\) parameters (with \\(X\\)) and transform them to a probability vector. #&#39; Description goes here #&#39; #&#39; @param ga document this carefully #&#39; @param Xp 1 vector appended to left of covariate matrix X. #&#39; #&#39; @export #&#39; @return (OO x OO) matrix with each row.. post_process_pie &lt;- function(Xp,ga){ Xga &lt;- Xp %*% ga pie.SB &lt;- 1/(1+exp(-Xga)) return(t(apply(pie.SB,1, SB2MN))) } Here’s a helper function to get the censoring limits. #&#39; Helper to obtain the censoring limits |Cbox|, which is a 2-colum matrix with columns |bounds.lower| and |bounds.upper|. #&#39; #&#39; @param ylist List of d-dimensional cytogram data. #&#39; #&#39; @export #&#39; @return dimdat by 2 matrix get_Cbox &lt;- function(ylist){ bounds.lower &lt;- lapply(ylist,function(xx) Rfast::colMins(xx,value = TRUE)) %&gt;% do.call(rbind,.) %&gt;% Rfast::colMins(.,value = TRUE) bounds.upper &lt;- lapply(ylist,function(xx) Rfast::colMaxs(xx,value = TRUE)) %&gt;% do.call(rbind,.) %&gt;% Rfast::colMaxs(.,value = TRUE) Cbox &lt;- cbind(bounds.lower,bounds.upper) } "],["syntheticdata.html", "4 Generating synthetic data", " 4 Generating synthetic data Here are some simple functions to generate 1d data. This code uses data from the flowmix AOAS paper. (More generally, the MCMC function takes mainly ylist, countslist, and X as data.) There are two scenarios we will test out in our paper: One-dimensional data, two clusters. Keep censor boundaries, but move the top cluster towards top censor boundary. One-dimensional data, two clusters. Keep means constant, but move the censor boundaries towards the center. (not done yet!) First load existing cytogram data and flowmix model estimates. (The two data files MGL1704-hourly-paper-1d-diam.RDS, 1d-cvres.rds, which can be downloaded from the flowmix R package, is assumed to be in inst/data from the base directory of the repository.) ## dat_1d = readRDS(&quot;~/Downloads/paper-data/MGL1704-hourly-paper-1d-diam.RDS&quot;) ## res = readRDS(&quot;~/Downloads/paper-data/1d-cvres.rds&quot;) %&gt;% .$bestres datadir = &quot;../inst/data&quot; dat_1d = readRDS(file.path(datadir, &quot;MGL1704-hourly-paper-1d-diam.RDS&quot;)) res = readRDS(file.path(datadir, &quot;1d-cvres.rds&quot;)) %&gt;% .$bestres ## Take two clusters&#39; model parameters (Picoeukaryotes and Prochlorococcus) orig_model = list() orig_model$alpha = res$alpha[c(3,4),,drop=FALSE] orig_model$beta = res$beta[c(3,4)] orig_model$sigma = res$sigma[c(3,4),1,1,drop=FALSE] orig_model$dimdat = res$dimdat orig_model$numclust = res$numclust orig_model$TT = res$TT ## Covariates are the same orig_model$X = res$X ## Save the &quot;original model&quot; ## saveRDS(orig_model, file=file.path(&quot;~/repos/flowcut/inst/output&quot;, &quot;orig_model.RDS&quot;)) ## outputdir = &quot;~/repos/flowcut/inst/output&quot; outputdir = &quot;../inst/data&quot; saveRDS(orig_model, file=file.path(outputdir, &quot;orig_model.RDS&quot;)) Next, we’ll make several versions of this model with isignal from 0 to 10; (1) isignal=0 means the means are completely overlapping. (2) isignal=10 is the highest signal size (gap between the two means). The cluster probabilities are set to be all 1/2 everywhere. This means that the true \\(\\alpha\\) coefficients are zero. (TODO: Check object classes and restrict to flowmix or flowcut (but not flowtrend) model objects.) #&#39; From an original set of model parameters (|true_model|), #&#39; generate synthetic 2-cluster 1-dimensional data with equal probabilities. #&#39; #&#39; @param isignal 0 to 10, which generates the means. #&#39; @param orig_model Original model of class flowmix or flowcut; a list that contains alpha, beta and TT. #&#39; #&#39; @return A list with beta, mn, alpha, prob, X, sigma, TT, numclust. #&#39; @export make_model &lt;- function(orig_model, isignal){ ## Setup stopifnot(isignal %in% 0:10) new_model = orig_model new_model$numclust = 2 ## Not used now: Renormalize the probabilities if(FALSE){ link = cbind(1, orig_model$X) %*% t(orig_model$alpha) new_model$prob = exp(link) / rowSums(exp(link)) new_model$prob %&gt;% matplot(type = &#39;l&#39;, lty = 1) } ## We are actually just going to use flat probabilities, for now. alphamat = orig_model$alpha alphamat[,-1] = 0 alphamat[,1] = 1 new_model$alpha = alphamat new_model$prob = matrix(1/2, nrow = orig_model$TT, ncol = 2) ## Take the two intercepts intp_high = orig_model$beta %&gt;% .[[1]]%&gt;% .[&quot;intp&quot;,] intp_low = orig_model$beta %&gt;% .[[2]]%&gt;% .[&quot;intp&quot;,] increment = (intp_high - intp_low)/10 ## Bring the larger mean down. new_model$beta[[1]][&quot;intp&quot;,] = intp_low + increment * isignal new_model$mn = array(NA, dim = c(orig_model$TT, 1, 2)) new_model$mn[,,1] = (cbind(1,new_model$X)) %*% (new_model$beta[[1]]) new_model$mn[,,2] = (cbind(1,new_model$X)) %*% (new_model$beta[[2]]) ## Optional: plot the means if(FALSE){ new_model$mn[,1,] %&gt;% matplot(type = &#39;l&#39;, lty = 1) } return(new_model) } par(mfrow = c(3,1)) new_model = make_model(orig_model, 0) new_model$mn %&gt;% .[,1,] %&gt;% matplot(type=&#39;l&#39;, main = paste0(&quot;isignal=&quot;, 0), ylim = c(-0.5, 0.6)) new_model = make_model(orig_model, 5) new_model$mn %&gt;% .[,1,] %&gt;% matplot(type=&#39;l&#39;, main = paste0(&quot;isignal=&quot;, 5), ylim = c(-0.5, 0.6)) new_model = make_model(orig_model, 10) new_model$mn %&gt;% .[,1,] %&gt;% matplot(type=&#39;l&#39;, main = paste0(&quot;isignal=&quot;, 10), ylim = c(-0.5, 0.6)) Then, we will generate data from this model using the function gen_1d(). #&#39; Generate 1d data with 2 clusters from a list (|true_model|) #&#39; containing true model parameters. #&#39; #&#39; @param true_model List containing beta, alpha, mn, prob, numclust. #&#39; @param nt Particles per time point. #&#39; #&#39; @return Cytograms (a |ylist| object) #&#39; @export gen_1d &lt;- function(true_model, nt = 1000){ ## Setup stopifnot(true_model$numclust == 2) TT = dim(true_model$mn)[1] ## Generate cytograms ylist = list() for(tt in 1:TT){ ## Generate memberships Samples |nt| memberships out of (1:numclust) ## according to the cluster probabilities in |prob|. nt_by_clust = stats::rmultinom(1, size = nt, true_model$prob[tt,]) ## draws = sample(1:numclust, size = nt, replace = TRUE, prob = true_model$prob[tt,]) draws = c(rep(1, nt_by_clust[1]), rep(2, nt_by_clust[2])) y_onetime = list() for(iclust in 1:true_model$numclust){ ntk = nt_by_clust[iclust] membership = rep(iclust, ntk) y_onetime[[iclust]] = cbind(MASS::mvrnorm(n = ntk, mu = true_model$mn[tt,,iclust], Sigma = true_model$sigma[iclust,,])) } y = do.call(rbind, y_onetime) ## Data ylist[[tt]] = y } return(ylist) } (TODO We’ll generate data particles with probability proportional to 1/biomass.) Testing this function out. ## Generate data set.seed(100) new_model = make_model(orig_model, 8) ylist = gen_1d(new_model, nt = 100) flowtrend::plot_1d(ylist, obj = new_model) ## Censor it ylist = lapply(ylist, function(y){ y = pmin(y, 0.5) }) flowtrend::plot_1d(ylist, obj = new_model) ## Form the censored &quot;box&quot; Cbox = rbind(c(-Inf, 0.5)) (TODO: Maybe we will use fewer than 40 coefficients. Let’s get the top 10 coefficients by importance, and only use them.) "],["gibbs-sampler.html", "5 Gibbs sampler 5.1 The main Gibbs sampler", " 5 Gibbs sampler 5.1 The main Gibbs sampler The main Gibbs sampler is called run.Gibbs.fast(). TODO items: We should write a function that makes a Cbox object. We should write what user.prior refers to. We should write what gg refers to, precisely. &lt;– actually, we should have maxdev as an input. #&#39; Runs a gibbs sampler to sample from the posterior distribution of the flowcut #&#39; model. #&#39; #&#39; @param ylist data. #&#39; @param countslist weights (counts) for data in |ylist|. #&#39; @param X covariates; a (p x T) matrix (TODO: change code so that X is T x p). #&#39; @param numclust NUmber of clusters. #&#39; @param Nmc Number of MCMC iterations #&#39; @param Nburn Number of burn-in iterations. #&#39; @param Cbox Censored box. #&#39; @param user.prior User-supplied prior. Otherwise, prior defaults to ___. #&#39; @param gg Size of Normal prior. #&#39; @param verbose Whether to be loud. #&#39; @param warm.start If supplied, restart the MCMC at these values. #&#39; @param tol NOT USED. #&#39; @param n.cores Number of cores for multiple cores. #&#39; #&#39; #&#39; @return #&#39; #&#39; @export run.Gibbs.fast &lt;- function(ylist, countslist, X, numclust, Nmc = 3000, Nburn = 500, Cbox = NULL, user.prior = NULL, gg = 1, sig2_gamma = 1, prior_spec.list = NULL, verbose = FALSE, last.imputed = NULL, last.para = NULL, tol = 1/1e8, n.cores = 1){ ## Basic setup TT &lt;- length(ylist) stopifnot(TT == ncol(X)) p &lt;- dim(X)[1] dimdat = ncol(ylist[[1]]) ntlist = sapply(ylist, nrow) NN &lt;- sum(ntlist) tt.impute &lt;- min(20,floor(Nburn/5)) n.cores = min(n.cores, TT) numclust &lt;- as.integer(numclust) dat.info &lt;- list(ylist = ylist, X= X, countslist = countslist, numclust = numclust, Cbox = Cbox) ## store raw data ##### pre computed quantities X.list &lt;- as.list(as.data.frame(X)) Xp &lt;- rbind(1,X) ## p+1 x TT Xp.list &lt;- as.list(as.data.frame(Xp)) countsTotal &lt;- sapply(countslist,sum) %&gt;% sum() alpha.factor &lt;- NN/countsTotal W.list &lt;- lapply(countslist, function(xx) xx*alpha.factor) W.sq.list &lt;- lapply(W.list, function(xx) sqrt(xx)) mt &lt;- lapply(W.list, sum)%&gt;%unlist() MM &lt;- sum(mt) XtXtT &lt;- lapply(X.list,function(x) x%*%t(x)) XtXtTp &lt;- lapply(Xp.list, function(x) x%*%t(x)) ggXtXtTp &lt;- lapply(Xp.list, function(x) x%*%t(x)/gg) XTX &lt;- X%*%t(X) XTXp &lt;- Xp%*%t(Xp) inv.XTX &lt;- Rfast::spdinv(XTX) inv.XTXp &lt;- Rfast::spdinv(XTXp) X0 &lt;- rbind(0, X) XTX0 &lt;- X0%*%t(X0) XXp.inv.sig &lt;- XTXp / sig2_gamma ## Build censored box if(!is.null(Cbox)){ Censor.list &lt;- parallel::mclapply(ylist, function(x) censorIndicator(x,Cbox), mc.cores = n.cores) censor.01.list &lt;- parallel::mclapply(Censor.list, function(x) apply(x,1, function(xx) sum(abs(xx))&gt;0), mc.cores = n.cores) censored.ylist &lt;- parallel::mcmapply(function(yy,c01) {yy[c01==TRUE,,drop=FALSE]}, yy = ylist, c01 = censor.01.list, mc.cores = n.cores) censored.C.list &lt;- parallel::mcmapply(function(c01,cc){cc[c01==TRUE,,drop=FALSE]}, c01 = censor.01.list, cc=Censor.list, mc.cores = n.cores) censored.W.list &lt;- parallel::mcmapply(function(c01,ww){ww[c01==TRUE]}, c01 = censor.01.list, w=W.list, mc.cores = n.cores) ntlist.censor &lt;- sapply(censor.01.list, sum) samp.region.list &lt;- lapply(1:TT, function(tt){ c01 &lt;- censor.01.list[[tt]] cc &lt;- Censor.list[[tt]] ## if(verbose){ ## print(paste(&quot;Time=&quot;,tt,&quot;, censored obs.= &quot;,sum(c01==TRUE), ## &quot;, censored ratio =&quot;, round(sum(c01==TRUE)/ntlist[tt],2), sep=&quot; &quot;)) ##} if(sum(c01==TRUE)&gt;1){ apply(cc[c01==TRUE,,drop=FALSE],1,function(xx) ## flowcut:::sample.region(xx,Cbox)) sample.region(xx,Cbox)) }else if(sum(c01==TRUE)==1){ matrix(sample.region(cc[c01==TRUE,,drop=FALSE],Cbox),ncol=1) }else{ NULL }}) } ##### prior specifications if(is.null(user.prior)){ nu0=dimdat nu1=p+1 S0=diag(dimdat) S1=diag(p+1) ## a_gamma &lt;- gamma.ab[1] ## b_gamma &lt;- gamma.ab[2] invNugget &lt;- 1/sig2_gamma prior.spec.list &lt;- list(nu0 = nu0, S0 = S0, ## a_gamma = a_gamma, ## b_gamma = b_gamma, sig2_gamma = sig2_gamma, gg = gg) ## inv.Omega &lt;- solve(S1) } ##### initialize if(!is.null(last.para)){ print(&quot;The MCMC continues with a previous draw of model parameters&quot;) beta.ell &lt;- last.para$beta gamma.ell &lt;- last.para$gamma Sig.ell &lt;- last.para$Sigma ## invNugget &lt;- last.para$invNugget Nburn &lt;- 0 ## no need of burn-in tt.impute &lt;- 0 }else{ print(&quot;The MCMC starts with a draw of model parameters from the prior&quot;) beta.ell &lt;- array(stats::rnorm(numclust*(p+1)*dimdat), c(dimdat,p+1,numclust)) gamma.ell &lt;- matrix(stats::rnorm((p+1)*(numclust-1)),nrow=p+1,ncol=numclust-1) Sig.ell &lt;- matrixsampling::rinvwishart(numclust,nu0+dimdat,S0)## %&gt;% as.matrix() } if(!is.null(last.imputed)){ print(&quot;continue with previously imputed latent variables.&quot;) Z.list &lt;- last.imputed$Z.list ylist &lt;- last.imputed$ylist Nburn &lt;- 0 ## no need of burn-in tt.impute &lt;- 0 } SX.ell &lt;- array(0, c(p,p,numclust)) Sy.ell &lt;- matrix(0,nrow = dimdat, ncol = TT) Sxy.ell &lt;- array(0, c(p,dimdat,numclust)) ##### store ## burn.beta0 &lt;- array(0,c(dimdat,numclust,Nburn)) ## burn.beta &lt;- array(0,c(dimdat,p,numclust,Nburn)) burn.beta &lt;- array(0,c(dimdat,p+1,numclust,Nburn)) burn.Sigma &lt;- array(0,c(dimdat,dimdat,numclust,Nburn)) burn.gamma &lt;- array(0,c(p+1,numclust-1,Nburn)) ## burn.invNugget &lt;- rep(NA, Nburn) ## burn.Omega &lt;- array(0,c(p+1,p+1,Nburn)) burn.avgloglik &lt;- rep(NA, Nburn) ## pos.beta0 &lt;- array(0,c(dimdat,numclust,Nmc)) ##pos.beta &lt;- array(0,c(dimdat,p,numclust,Nmc)) pos.beta &lt;- array(0,c(dimdat,p+1,numclust,Nmc)) pos.Sigma &lt;- array(0,c(dimdat,dimdat,numclust,Nmc)) pos.gamma &lt;- array(0,c(p+1,numclust-1,Nmc)) ##pos.Omega &lt;- array(0,c(p+1,p+1,Nmc)) ##pos.invNugget &lt;- rep(NA, Nmc) pos.avgloglik &lt;- rep(NA, Nmc) ## if(is.null(Cbox)==FALSE){ ## pos.imputedimdat.Y &lt;- array(0,c(dimdat,sum(nt.censor),Nmc)) ## } if(verbose){ print(&quot;The Gibbs sampler starts now.&quot;) list.iter &lt;- c(1, Nburn+1, 1:floor((Nmc+ Nburn-1)/100)*100, Nmc + Nburn) ptm &lt;- NULL } ##### posterior sampling starts here for(jj in 1:(Nburn+Nmc)) { cat(&quot;MCMC iteration:&quot;, jj, fill = TRUE) if(verbose){ if(jj ==1 &amp; Nburn &gt; 0){ print(&quot;Burn-in period starts.&quot;) print(Sys.time()) } if(jj == tt.impute + 1){ ptm &lt;- proc.time() print(Sys.time()) } if(jj ==Nburn+1 &amp; Nburn &gt; 0){ plot(burn.avgloglik[(tt.impute+1):Nburn], type=&quot;l&quot;,lwd=2) print(paste(&quot;Burn-in sample size: &quot;, Nburn, sep = &quot; &quot;)) print(&quot;Burn-in period ends.&quot;) print(&quot;Burn-in time cost per iteration, in seconds&quot;) burn.tc &lt;- (proc.time()-ptm)/(Nburn - tt.impute) print(round(burn.tc,2)) print(Sys.time()) print(&quot;Collecting posterior samples......&quot;) print(paste(&quot;Expected time to draw&quot;, Nmc, &quot;posterior samples: &quot;, round(burn.tc[3]*Nmc/60/60,2), &quot; hours&quot;, sep=&quot; &quot;)) } if(jj %in% list.iter &amp; jj &gt; Nburn){ progress(jj - Nburn,Nmc) } if(jj %in% list.iter &amp; jj &lt; Nburn+1){ progress(jj,Nburn) } } ################################################ ## expert assignment ### ################################################ XpGamma &lt;- Rfast::Crossprod(gamma.ell, Xp) ## K-1 x TT pi.sb &lt;- 1/(1+exp(-XpGamma)) ## stick-breaking representation pi.mn &lt;- apply(pi.sb, 2, SB2MN) ## discrete prob vector logpi.list &lt;- parallel::mclapply(1:TT, function(t) log(pi.mn[,t]), mc.cores = min(n.cores,TT)) chol.Sig.ell &lt;- apply(Sig.ell,3, chol) if(dimdat == 1) chol.Sig.ell = rbind(chol.Sig.ell) chol.Sig.list &lt;- lapply(1:numclust,function(kk) matrix(chol.Sig.ell[,kk], nrow = dimdat)) ## mu.list &lt;- lapply(1:TT, function(tt){ ## one_mu = sapply(1:numclust, function(kk){ ## ## if(dimdat == 1){ ## ## beta.ell[,,kk,drop=FALSE] %*% Xp[,tt,drop=FALSE]} ## ## else{ ## beta.ell[,,kk] %*% Xp[,tt,drop=FALSE] ## } ## }) ## if(dimdat==1) one_mu = rbind(one_mu) ## return(one_mu) ## }) mu.list &lt;- parallel::mclapply(Xp.list, function(xx){ apply(beta.ell, c(1,3), function(bb) bb %*% xx) }, mc.cores= n.cores) logPiZ &lt;- parallel::mcmapply(function(xx, yy, mm, pp){ sapply(1:numclust, function(kk) mvnfast::dmvn(yy, mm[,kk], chol.Sig.list[[kk]], log=TRUE, isChol = TRUE) + pp[kk])}, ## mod here xx =X.list, yy = ylist, mm = mu.list, pp=logpi.list, mc.cores = n.cores, SIMPLIFY = FALSE) Z.list &lt;- parallel::mclapply(logPiZ, function(pp) apply(pp,1, function(lpi) .Internal(sample(numclust, 1, TRUE, prob = softmax(lpi)))), mc.cores = n.cores) ################################################ ## censored data imputation ################################################ if((jj&gt; tt.impute | !is.null(last.para)) &amp; !is.null(Cbox)){ censored.Z.list &lt;- parallel::mcmapply(function(c01,zz){zz[c01==TRUE]}, c01 = censor.01.list, zz=Z.list, mc.cores = n.cores) imputed.ylist &lt;- parallel::mclapply(1:TT, function(tt) { yy = impute.censored(ww = censored.W.list[[tt]], yy = censored.ylist[[tt]], zz = censored.Z.list[[tt]], cc.info.mat = censored.C.list[[tt]], bounds.mat = samp.region.list[[tt]], mu.mat = mu.list[[tt]], Sigma.ell = Sig.ell, dimdat = dimdat) if(dimdat==1 &amp; !is.null(yy)) yy = t(yy) return(yy) }, mc.cores = n.cores, mc.preschedule = FALSE) for(tt in 1:TT){ censored_particles = which(censor.01.list[[tt]]) ##stopifnot(nrow(imputed.ylist[[tt]]) == length(censored_particles)) ylist[[tt]][censored_particles,] &lt;- imputed.ylist[[tt]] } } loglik &lt;- loglik_eval(mu.list, chol.Sig.list, W.list, X.list, ylist, Z.list, as.list(ntlist), simple = TRUE) ## print(sort(round(n.ell/NN,3))) ## print(sort(round(m.ell/MM,3))) if(jj %% 10 == 0) print(paste(&quot;avg loglikelihood: &quot;, round(loglik,2), sep=&quot; &quot;)) ################################################ ## SBMN-logit parameter estimation ### ################################################ mt.ell &lt;- parallel::mcmapply(function(ww,zz){ sapply(1:numclust, function(kk) sum(ww[zz==kk]))}, ww = W.list, zz = Z.list, SIMPLIFY = TRUE, mc.cores = n.cores) m.ell &lt;- Rfast::rowsums(mt.ell) XpGamma.abs &lt;- Rfast::Crossprod(gamma.ell, Xp) %&gt;% abs() ## numclust-1 x TT mt.cumsum &lt;- Rfast::colCumSums(as.matrix(mt.ell)) Mt.ell &lt;- rbind(mt, -sweep(mt.cumsum[-numclust,,drop=FALSE], 2, mt.cumsum[numclust, , drop=FALSE])) #### omega.tell &lt;- matrix(parallel::mcmapply(pgdraw::pgdraw, omega.tell &lt;- matrix(parallel::mcmapply(pgdraw.mod, ### mod here round(Mt.ell[-numclust,]), XpGamma.abs, mc.cores = n.cores), nrow=numclust-1, ncol = TT) kappa &lt;- mt.ell[-numclust, , drop=FALSE] - Mt.ell[-numclust, , drop=FALSE]/2 ## inv.Omega &lt;- Rfast::spdinv(Omega) ## for(ell in 1:(numclust-1)){ ## V.omell &lt;- Rfast::spdinv(Reduce(&#39;+&#39;, Map(&#39;*&#39;, XtXtTp, omega.tell[ell,])) ## + XXp.inv.sig) ## m.omell &lt;- V.omell %*% Reduce(&#39;+&#39;, Map(&#39;*&#39;, Xp.list , kappa[ell,]) ) ## gamma.ell[,ell] &lt;- Rfast::rmvnorm(1, m.omell, V.omell) ## } V.omell &lt;- parallel::mclapply(1:(numclust-1), function(ell){ Rfast::spdinv(Reduce(&#39;+&#39;, Map(&#39;*&#39;, XtXtTp, omega.tell[ell,])) + XXp.inv.sig)}, mc.cores = n.cores) gamma.ell.list &lt;- parallel::mclapply(1:(numclust-1), function(ell){ Rfast::rmvnorm(1, V.omell[[ell]] %*% Reduce(&#39;+&#39;, Map(&#39;*&#39;, Xp.list , kappa[ell,]) ), V.omell[[ell]])} , mc.cores = n.cores) gamma.ell &lt;- gamma.ell.list %&gt;% unlist() %&gt;% matrix(., nrow = p+1, ncol = numclust -1) ## a_gamma_n &lt;- numclust-1+a_gamma ## b_gamma_n &lt;- apply(t(X0) %*% gamma.ell, 2, crossprod) %&gt;% sum() + b_gamma ## invNugget &lt;- 1 / stats::rgamma(1, a_gamma_n/2, b_gamma_n/2) ################################################ ## experts&#39; estimation ### ################################################ for(ell in 1:numclust){ ## sample beta (including the intercept) jointly SX.ell &lt;- XTX0/gg + Reduce(&#39;+&#39;, Map(`*`, XtXtTp, mt.ell[ell,])) inv.SX.ell &lt;- Rfast::spdinv(SX.ell) ## (p+1) x (p+1) Sy.ell &lt;- parallel::mcmapply(function(yy,zz,ww){ Rfast::Crossprod(as.matrix(ww[zz==ell]), yy[zz==ell,,drop=FALSE])}, ww = W.list, yy = ylist, zz = Z.list, SIMPLIFY = TRUE, mc.cores = n.cores) if(dimdat==1){ Sxy.ell &lt;- Xp %*% as.matrix(Sy.ell) ## (p+1) x 1 }else{ Sxy.ell &lt;- Rfast::Tcrossprod(Xp, Sy.ell) ## (p+1) x d } beta.ell[,,ell] &lt;- rmatnorm.fast(M = crossprod(Sxy.ell,inv.SX.ell), U = Sig.ell[,,ell], V = inv.SX.ell) sse &lt;- parallel::mcmapply(function(ww,xx,yy,zz) { wcrossprod.fast(Rfast::eachrow(as.matrix(yy[zz==ell,,drop=FALSE]), beta.ell[,,ell]%*%xx, &#39;-&#39;), ww[zz==ell], weighting = TRUE)}, xx = Xp.list, yy = ylist, zz=Z.list, ww = W.sq.list, SIMPLIFY = FALSE, mc.cores = n.cores) if(dimdat == 1) Sn.ell = sum(unlist(sse)) if(dimdat &gt; 1) Sn.ell &lt;- Reduce(&#39;+&#39;,sse[sapply(sse,length)&gt;0]) Sig.ell[,,ell] &lt;- matrixsampling::rinvwishart(1, nu0+dimdat + m.ell[ell], S0 + Sn.ell)[,,1] } ############################################### ## collecting posterior samples ############################################## if(jj &gt;Nburn){ pos.beta[,,,jj-Nburn] &lt;- beta.ell pos.Sigma[,,,jj-Nburn] &lt;- Sig.ell pos.gamma[,,jj-Nburn] &lt;- gamma.ell ## pos.invNugget[ jj-Nburn ] &lt;- invNugget pos.avgloglik[jj-Nburn] &lt;- loglik } else{ burn.beta[,,,jj] &lt;- beta.ell burn.Sigma[,,,jj] &lt;- Sig.ell burn.gamma[,,jj] &lt;- gamma.ell ## burn.invNugget[jj] &lt;- invNugget burn.avgloglik[jj] &lt;- loglik } } ########## MCMC stops here. if(verbose ){ print(&quot;All work is done.&quot;) print(paste(&quot;Stored MCMC sample size: &quot;, Nmc, sep = &quot; &quot;)) print(Sys.time()) print(&quot;total time cost, in min&quot;) print(round((proc.time()-ptm)/60,1)) print(&quot;total time cost, in hours&quot;) print(round((proc.time()-ptm)/60/60,2)) print(&quot;time cost per iteration, in seconds&quot;) print((proc.time()-ptm)/(Nburn+Nmc - tt.impute)) } last.imputed &lt;- list(last.ylist = ylist, last.Z.list = Z.list) last.para &lt;- list(last.gamma = gamma.ell, last.beta = beta.ell, last.Sigma = Sig.ell ## last.invNugget = invNugget ) if(is.null(Cbox)){ ret &lt;- list( ## burn.beta0=burn.beta0, burn.beta=burn.beta,burn.Sigma=burn.Sigma, burn.gamma=burn.gamma, ## burn.Omega=burn.Omega, ## pos.beta0=pos.beta0, pos.beta=pos.beta, pos.Sigma=pos.Sigma, pos.gamma=pos.gamma, ## pos.Omega=pos.Omega, burn.avgloglik=burn.avgloglik, pos.avgloglik=pos.avgloglik, ## burn.invNugget = burn.invNugget, ## pos.invNugget=pos.invNugget, dat.info = dat.info , last.imputed = last.imputed, last.para = last.para, prior.spec = prior.spec.list) }else{ ret &lt;- list( ## burn.beta0 = burn.beta0, burn.beta = burn.beta, burn.Sigma = burn.Sigma, burn.gamma = burn.gamma, pos.beta = pos.beta, pos.Sigma = pos.Sigma, pos.gamma = pos.gamma, pos.imputed.Y = do.call(rbind, imputed.ylist), ## burn.invNugget = burn.invNugget, ## pos.invNugget=pos.invNugget, burn.avgloglik = burn.avgloglik, pos.avgloglik = pos.avgloglik, dat.info = dat.info , last.imputed = last.imputed, last.para = last.para, prior.spec = prior.spec.list) } return(ret) } ## benchmark(&quot;ss&quot;={sapply(1:TT, function(t) sapply(1:(numclust-1), function(kk) ## pgdraw(Nt.ell[kk,t],abs(XpGamma[kk,t]))))}, ## &quot;mcmapp&quot;={matrix(mcmapply(pgdraw, Nt.ell[-numclust,], abs(XpGamma), ## mc.cores = n.cores), ## nrow=numclust-1, ncol = TT)}, ## &quot;mapp&quot;={matrix(mapply(pgdraw, Nt.ell[-numclust,], abs(XpGamma)), ## nrow=numclust-1, ncol = TT)}, ## replications = 10, ## columns = c(&quot;test&quot;, &quot;replications&quot;, &quot;elapsed&quot;, ## &quot;relative&quot;, &quot;user.self&quot;, &quot;sys.self&quot;)) "],["simulations.html", "6 Simulations", " 6 Simulations Refer back to the data generation in @ref{syntheticdata}. We will be top-censoring the data at 0.5. Before censoring, this is what the data looks like. ## Load the &quot;original&quot; model orig_model = readRDS(file=file.path(&quot;~/repos/flowcut/inst/output&quot;, &quot;orig_model.RDS&quot;)) ## Generate data set.seed(100) isignal = 8 new_model = flowcut::make_model(orig_model, isignal) ylist = flowcut::gen_1d(new_model, nt = 100) flowtrend::plot_1d(ylist, obj = new_model) After censoring, this is it. ## Censor it ylist = lapply(ylist, function(y){ y = pmin(y, 0.5) }) flowtrend::plot_1d(ylist, obj = new_model) We need to specify a few things (1) like the censoring limits Cbox and (2) countslist before running the MCMC. ## Form the censoring &quot;box&quot; Cbox = rbind(c(-Inf, 0.5)) ## Counts are all equal for now countslist = lapply(ylist, function(y){ rep(1, nrow(y)) }) ## Save the metadata datobj = list(ylist=ylist, countslist=countslist, Cbox=Cbox, X=orig_model$X) saveRDS(datobj, file.path(&quot;~/repos/flowcut/inst/output&quot;, paste0(&quot;isignal-&quot;, isignal, &quot;-datobj.RDS&quot;))) We also need some prior elicitation to prevent the cluster means from changing too much across time. (code copy-pasted as-is for now, not meant to be run) gg &lt;- maxdev_to_gg(datobj$X, dimdat = 3, maxdev = 0.5, numclust = 10, ggvec = (1:40)/200, n.cores = detectCores(), Nmc = 1e4, viz=FALSE) gg &lt;- 0.01287879 ## hist(ball.deviance(0.01,0.5,t(X))$msd, breaks = &quot;FD&quot;) ## hist(ball.deviance(0.1,0.5,X)$msd, breaks = &quot;FD&quot;) ## hist(ball.deviance(0.2,0.5,X)$msd, breaks = &quot;FD&quot;) ## hist(ball.deviance(0.5,0.5,X)$msd, breaks = &quot;FD&quot;) ## hist(ball.deviance(1,0.5,X)$msd, breaks = &quot;FD&quot;) ## hist(ball.deviance(2,0.5,X)$msd, breaks = &quot;FD&quot;) Next, we run the MCMC. ## Run the MCMC Nmc &lt;- 1e3 * 5 Nburn &lt;- 500 Nmc &lt;- 20 Nburn &lt;- 10 set.seed(123) Gibbs.res &lt;- run.Gibbs.fast(ylist = datobj$ylist, countslist = datobj$countslist, numclust = 2, Nmc = Nmc, Nburn = Nburn, gg = 0.1, X = t(datobj$X), Cbox = datobj$Cbox, verbose = TRUE) ## Save the results saveRDS(Gibbs.res, file.path(&quot;~/repos/flowcut/inst/output&quot;, paste0(&quot;isignal-&quot;, isignal, &quot;-gibbs.RDS&quot;))) "],["real-data-example.html", "7 Real data example", " 7 Real data example We run the Gibbs sampler on real data. We’ll load the data, process it, then feed it into the MCMC. TODO: bundle the Cbox into a make_Cbox() function. Why are we doing more.censor() manually? Simplify/streamline this. ## Load the code for running MCMC ## codedir = &quot;~/Dropbox/Apps/Overleaf/censor-flowmix/BMEcensor/code/&quot; codedir = &quot;~/Dropbox/Apps/Overleaf/censor-flowmix/BMEcensor/code/&quot; source(file.path(codedir, &#39;BME-functions.r&#39;)) ## Load dataset datadir = &quot;~/Dropbox/research-new/censored-flowmix/code/data&quot; dta &lt;- readRDS(file.path(datadir, &quot;pre-censor-datobj.RDS&quot;)) ## Assign data to objects ylist &lt;- dta$ylist TT &lt;- length(ylist) d &lt;- 3 countslist = dta$countslist ## Define censor limits bounds.lower &lt;- rowMins(matrix(unlist( lapply(dta$ylist, function(xx) colMins(xx,value = TRUE))), nrow = d), value = TRUE) bounds.upper &lt;- rowMaxs(matrix(unlist( lapply(dta$ylist, function(xx) colMaxs(xx,value = TRUE))), nrow = d), value = TRUE) ## Censor the first dimension a bit more Cbox &lt;- cbind(signif(log(bounds.lower),5), log(bounds.upper)) more.censor &lt;- function(ymat,bd){ cbind(sapply(ymat[,1], function(xx) ifelse(xx&lt;bd, bd, xx)), ymat[,c(2,3)]) } ylist &lt;- mclapply(dta$ylist, function(yy){ more.censor(log(yy),Cbox[1,1]), }, mc.cores = min(n.cores, TT)) ## Checking that censoring is done properly assertthat::assert_that(all(rowMins(matrix(unlist( lapply(ylist, function(xx) colMins(xx,value = TRUE))), nrow = d), value = TRUE) == Cbox[,1])) assertthat::assert_that(all(rowMaxs(matrix(unlist( lapply(ylist, function(xx) colMaxs(xx,value = TRUE))), nrow = d), value = TRUE) == Cbox[,2])) ## Clean data datobj &lt;- list(ylist = ylist, countslist = dta$countslist, X = dta$X, numclust = 10, Cbox=Cbox) ## Run the MCMC Nmc &lt;- 1e3*5 Nburn &lt;- 500 K &lt;- 10 Gibbs.res0 &lt;- run.Gibbs.fast(ylist = datobj$ylist, countslist = datobj$countslist, X = datobj$X, numclust = datobj$numclust, gg = 0.1, Nmc = Nmc, Nburn = Nburn, Cbox = datobj$Cbox, verbose = TRUE, warm.start = NULL) "],["documenting-the-package-and-building.html", "8 Documenting the package and building", " 8 Documenting the package and building We finish by running commands that will document, build, and install the package. It may also be a good idea to check the package from within this file. litr::document() # &lt;-- use instead of devtools::document() ## ℹ Updating flowcut documentation ## ℹ Loading flowcut ## Loading required package: MASS ## ## ## Attaching package: &#39;MASS&#39; ## ## ## The following object is masked from &#39;package:dplyr&#39;: ## ## select ## ## ## Loading required package: matrixNormal ## ## ## Attaching package: &#39;matrixNormal&#39; ## ## ## The following object is masked from &#39;package:base&#39;: ## ## I ## ## ## Loading required package: matrixsampling ## ## Loading required package: mvnfast ## ## ## Attaching package: &#39;mvnfast&#39; ## ## ## The following object is masked from &#39;package:lubridate&#39;: ## ## ms ## ## ## Loading required package: parallel ## ## Loading required package: pgdraw ## ## Loading required package: Rfast ## ## Loading required package: Rcpp ## ## Loading required package: RcppZiggurat ## ## Loading required package: RcppParallel ## ## ## Attaching package: &#39;RcppParallel&#39; ## ## ## The following object is masked from &#39;package:Rcpp&#39;: ## ## LdFlags ## ## ## ## Rfast: 2.1.0 ## ## ___ __ __ __ __ __ __ __ __ __ _ _ __ __ __ __ __ __ __ __ __ __ __ ## | __ __ __ __ | | __ __ __ __ _/ / \\ | __ __ __ __ / /__ __ _ _ __ __\\ ## | | | | | | / _ \\ | | / / ## | | | | | | / / \\ \\ | | / / ## | | | | | | / / \\ \\ | | / / ## | |__ __ __ __| | | |__ __ __ __ / / \\ \\ | |__ __ __ __ _ / /__/\\ ## | __ __ __ __| | __ __ __ __| / /__ _ __\\ \\ |_ __ __ __ _ | / ___ / ## | \\ | | / _ _ _ _ _ _ \\ | | \\/ / / ## | |\\ \\ | | / / \\ \\ | | / / ## | | \\ \\ | | / / \\ \\ | | / / ## | | \\ \\ | | / / \\ \\ | | / / ## | | \\ \\__ __ _ | | / / \\ \\ _ __ __ __ _| | / / ## |_| \\__ __ __\\ |_| /_/ \\_\\ /_ __ __ __ ___| \\/ team ## ## ## Attaching package: &#39;Rfast&#39; ## ## ## The following objects are masked from &#39;package:mvnfast&#39;: ## ## dmvt, rmvt ## ## ## The following object is masked from &#39;package:dplyr&#39;: ## ## nth ## ## ## The following objects are masked from &#39;package:purrr&#39;: ## ## is_integer, transpose ## ## ## Loading required package: tmvnsim ## Warning: [run.Gibbs.fast.R:21] @return requires a value ## Writing &#39;NAMESPACE&#39; ## Writing &#39;NAMESPACE&#39; ## Writing &#39;printprogress.Rd&#39; ## Writing &#39;progress.Rd&#39; ## Writing &#39;SB2MN.Rd&#39; ## Writing &#39;MN2SB.Rd&#39; ## Writing &#39;flowcut-package.Rd&#39; ## Writing &#39;gen_1d.Rd&#39; ## Writing &#39;get_Cbox.Rd&#39; ## Writing &#39;make_model.Rd&#39; ## Writing &#39;maxdev_to_gg.Rd&#39; ## Writing &#39;post_process_pie.Rd&#39; ## Writing &#39;run.Gibbs.fast.Rd&#39; ## Writing &#39;pipe.Rd&#39; "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
